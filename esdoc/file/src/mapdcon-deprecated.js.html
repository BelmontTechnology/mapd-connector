<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/mapdcon-deprecated.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/map-d/mapd-con" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/mapd-con-es6.js~MapdCon.html">MapdCon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-mapdCon">mapdCon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TColumnType">TColumnType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TCopyParams">TCopyParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TDatum">TDatum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TDatumVal">TDatumVal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TDetectResult">TDetectResult</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TFrontendView">TFrontendView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TRow">TRow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TRowSet">TRowSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TServerStatus">TServerStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TTypeInfo">TTypeInfo</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/mapdcon-deprecated.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">(function(exports){
  mapdcon.version= &quot;1.0&quot;;
  exports.mapdcon = mapdcon;

  function mapdcon() {
    var mapdcon = {
      setPlatform: setPlatform,
      setHost: setHost,
      setUserAndPassword: setUserAndPassword,
      setPort: setPort,
      setDbName: setDbName,
      connect: connect,
      disconnect: disconnect,
      query: query,
      queryAsync: queryAsync,
      render: render,
      getSessionId: function() {return sessionId;},
      getHost: function() {return host},
      getPort: function() {return port},
      getUser: function() {return user},
      getDb: function() {return dbName},
      getUploadServer: function() {return &quot;&quot;}, // empty string: same as frontend server
      getDatabases: getDatabases,
      getTables: getTables,
      getFields: getFields,
      getPlatform: getPlatform,
      getClient: getClient,
      getFrontendViews: getFrontendViews,
      getFrontendView: getFrontendView,
      getServerStatus: getServerStatus,
      createFrontendView: createFrontendView,
      detectColumnTypes: detectColumnTypes,
      createTable: createTable,
      importTable: importTable,
      importTableStatus: importTableStatus,
      createLink: createLink,
      getLinkView: getLinkView,
      getRowsForPixels: getRowsForPixels,
      logging: logging 
    }

    var host = null;
    var user = null;
    var password = null; // to be changed
    var port = null;
    var dbName = null;
    var transport = null;
    var protocol = null;
    var client = null;
    var sessionId = null;
    var datumEnum = {};
    var nonce = 0;
    var _logging = false;

    function logging(_) {
      if (!arguments.length)
        return _logging;
      _logging = _;
      return mapdcon;
    }

    function setPlatform(newPlatform) {
      //dummy function for now
      return mapdcon;
    }

    function getPlatform() {
      return &quot;mapd&quot;;
    }
    function getClient() {
      return client;
    }

    function setHost(newHost) {
      host = newHost;
      return mapdcon;
    }

    function setUserAndPassword (newUser,newPassword) {
      user = newUser;
      password = newPassword;
      return mapdcon;
    }

    function setPort (newPort) {
      port = newPort;
      return mapdcon;
    }

    function setDbName (newDb) {
      dbName = newDb;
      return mapdcon;
    }

    function testConnection() {
      if (sessionId == null)  {
        return false;
        //throw &quot;Client not connected&quot;;
      }
      return true;
    }

    function connect() {
      transport = new Thrift.Transport(&quot;http://&quot; + host + &quot;:&quot; + port);
      protocol = new Thrift.Protocol(transport);
      client = new MapDClient(protocol);
      sessionId = client.connect(user, password, dbName);
      return mapdcon;
    }

    function disconnect() {
      if (sessionId != null) {
        client.disconnect(sessionId);
        sessionId = null;
      }
      client = null;
      protocol = null;
      transport = null;
    }

    function getFrontendViews() {
      var result = null;
      try {
        result = client.get_frontend_views(sessionId);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.get_frontend_views(sessionId);
        }
      }
      return result;
    }

    function getFrontendView(viewName) {
      var result = null;
      try {
        result = client.get_frontend_view(sessionId,viewName);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.get_frontend_views(sessionId,viewName);
        }
      }
      return result;
    }

    function getServerStatus() {
      var result = null;
      try {
        result = client.get_server_status();
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.get_server_status();
        }
      }
      return result;
    }


    function createFrontendView(viewName, viewState, imageHash) {
      try {
        client.create_frontend_view(sessionId, viewName, viewState, imageHash);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          var result = client.get_frontend_views(sessionId, viewName, viewState, imageHash);
        }
      }
    }

    function createLink(viewState) {
      try {
        result = client.create_link(sessionId, viewState);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.create_link(sessionId, viewState);
        }
      }
      return result;
    }

    function getLinkView(link) {
      try {
        result = client.get_link_view(sessionId, link);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.get_link_view(sessionId, link);
        }
      }
      return result;
    }

    function detectColumnTypes(fileName, copyParams, callback) {
      var result = null;
      copyParams.delimiter = copyParams.delimiter || &quot;&quot;;
      try {
        result = client.detect_column_types(sessionId, fileName, copyParams, callback);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.detect_column_types(sessionId, fileName, copyParams, callback);
        }
      }
      return result;
    }

    function render(query, renderSpec) {
      var result = null;
      try {
        result = client.render(sessionId, query, renderSpec, {}, {});

      }
      catch (err) {
        console.log(err);
      }
    }

    function queryAsync(query, columnarResults, eliminateNullRows, renderSpec, callbacks) {
      columnarResults = columnarResults === undefined ? true : columnarResults; // make columnar results default if not specified
      var curNonce = (nonce++).toString();
      try {
        if (renderSpec !== undefined) {
          client.render(sessionId, query + &quot;;&quot;, renderSpec, {}, {}, curNonce, processResults.bind(this, true, eliminateNullRows, &quot;render: &quot; + query, callbacks));
        }
        else {
          client.sql_execute(sessionId,query + &quot;;&quot;, columnarResults, curNonce, processResults.bind(this, false, eliminateNullRows, query, callbacks));
        }
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          client.sql_execute(sessionId,query + &quot;;&quot;, columnarResults, curNonce, processResults.bind(this, false, eliminateNullRows, query, callbacks));
        }
        else if (err.name == &quot;TMapDException&quot;) {
          swal({title: &quot;Error!&quot;,
            text: err.error_msg,
            type: &quot;error&quot;,
            confirmButtonText: &quot;Okay&quot;
          });

          // google analytics send error
          ga(&apos;send&apos;, &apos;event&apos;, &apos;error&apos;, &apos;async query error&apos;, err.error_msg, {
           nonInteraction: true
          });

        }
        else {
          throw(err);
        }
      }
      return curNonce;
    }

    function query(query,columnarResults,eliminateNullRows, renderSpec) {
      columnarResults = columnarResults === undefined ? true : columnarResults; // make columnar results default if not specified
      var result = null;
      var curNonce = (nonce++).toString();
      try {
        if (renderSpec !== undefined) {
          result = client.render(sessionId, query + &quot;;&quot;, renderSpec, {}, {}, curNonce);
        }
        else {
          result = client.sql_execute(sessionId,query + &quot;;&quot;,columnarResults, curNonce);
        }
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.sql_execute(sessionId,query + &quot;;&quot;,columnarResults, curNonce);
        }
        else if (err.name == &quot;TMapDException&quot;) {
          swal({title: &quot;Error!&quot;,
            text: err.error_msg,
            type: &quot;error&quot;,
            confirmButtonText: &quot;Okay&quot;
          });

          // google analytics send error
          ga(&apos;send&apos;, &apos;event&apos;, &apos;error&apos;, &apos;query error&apos;, err.error_msg, {
           nonInteraction: true
          })
        }
        else {
          throw(err);
        }
      }

      if (renderSpec !== undefined)
        return result;
      return processResults(false, eliminateNullRows, renderSpec ? &quot;render: &quot; + query : query, undefined, result); // undefined is callbacks slot
    }

    function processColumnarResults(data,eliminateNullRows) {
      var formattedResult = {fields: [], results: []};
      var numCols = data.row_desc.length;
      var numRows = 0;
      for (var c = 0; c &lt; numCols; c++) {
        var field = data.row_desc[c];
        formattedResult.fields.push({&quot;name&quot;: field.col_name, &quot;type&quot;: datumEnum[field.col_type.type], &quot;is_array&quot;:field.col_type.is_array});
      }
      if (numCols &gt; 0)
        numRows = data.columns[0] !== undefined ? data.columns[0].nulls.length : 0;
      for (var r = 0; r &lt; numRows; r++) {
        if (eliminateNullRows) {
          var rowHasNull = false;
          for (var c = 0; c &lt; numCols; c++) {
            if (data.columns[c].nulls[r]) {
              rowHasNull = true;
              break;
            }
          }
          if (rowHasNull)
            continue;
        }
        var row = {};
        for (var c = 0; c &lt; numCols; c++) {
          var fieldName = formattedResult.fields[c].name;
          var fieldType = formattedResult.fields[c].type;
          var fieldIsArray = formattedResult.fields[c].is_array;
          var isNull = data.columns[c].nulls[r];
          if (isNull) {
            // row[fieldName] = &quot;NULL&quot;;
            row[fieldName] = null;
            continue;
          }
          if (fieldIsArray) {
            row[fieldName] = [];
            var arrayNumElems = data.columns[c].data.arr_col[r].nulls.length;
            for (var e = 0; e &lt; arrayNumElems; e++) {
              if (data.columns[c].data.arr_col[r].nulls[e]) {
                row[fieldName].push(&quot;NULL&quot;);
                continue;
              }
              switch(fieldType) {
                case &quot;BOOL&quot;:
                  row[fieldName].push(data.columns[c].data.arr_col[r].data.int_col[e] ? true : false);
                  break;
                case &quot;SMALLINT&quot;:
                case &quot;INT&quot;:
                case &quot;BIGINT&quot;:
                  row[fieldName].push(data.columns[c].data.arr_col[r].data.int_col[e]);
                  break;
                case &quot;FLOAT&quot;:
                case &quot;DOUBLE&quot;:
                case &quot;DECIMAL&quot;:
                  row[fieldName].push(data.columns[c].data.arr_col[r].data.real_col[e]);
                  break;
                case &quot;STR&quot;:
                  row[fieldName].push(data.columns[c].data.arr_col[r].data.str_col[e]);
                  break;
                case &quot;TIME&quot;:
                case &quot;TIMESTAMP&quot;:
                case &quot;DATE&quot;:
                  row[fieldName].push(data.columns[c].data.arr_col[r].data.int_col[e] * 1000);
                  break;
              }
            }
          }
          else {
            switch (fieldType) {
              case &quot;BOOL&quot;:
                row[fieldName] = data.columns[c].data.int_col[r] ? true : false;
                break;
              case &quot;SMALLINT&quot;:
              case &quot;INT&quot;:
              case &quot;BIGINT&quot;:
                row[fieldName] = data.columns[c].data.int_col[r];
                break;
              case &quot;FLOAT&quot;:
              case &quot;DOUBLE&quot;:
              case &quot;DECIMAL&quot;:
                row[fieldName] = data.columns[c].data.real_col[r];
                break;
              case &quot;STR&quot;:
                row[fieldName] = data.columns[c].data.str_col[r];
                break;
              case &quot;TIME&quot;:
              case &quot;TIMESTAMP&quot;:
              case &quot;DATE&quot;:
                row[fieldName] = new Date(data.columns[c].data.int_col[r] * 1000);
                break;
            }
          }
        }
        formattedResult.results.push(row);
      }
      return formattedResult;
    }


    function processRowResults(data, eliminateNullRows) {
      var numCols = data.row_desc.length;
      var colNames = [];
      var formattedResult = {fields: [], results: []};
      for (var c = 0; c &lt; numCols; c++) {
        var field = data.row_desc[c];
        formattedResult.fields.push({&quot;name&quot;: field.col_name, &quot;type&quot;: datumEnum[field.col_type.type], &quot;is_array&quot;:field.col_type.is_array});
      }
      formattedResult.results = [];
      var numRows = 0;
      if (data.rows !== undefined &amp;&amp; data.rows !== null)
        numRows = data.rows.length; // so won&apos;t throw if data.rows is missing
      for (var r = 0; r &lt; numRows; r++) {
        if (eliminateNullRows) {
          var rowHasNull = false;
          for (var c = 0; c &lt; numCols; c++) {
            if (data.rows[r].columns[c].is_null) {
              rowHasNull = true;
              break;
            }
          }
          if (rowHasNull)
            continue;
        }

        var row = {};
        for (var c = 0; c &lt; numCols; c++) {
          var fieldName = formattedResult.fields[c].name;
          var fieldType = formattedResult.fields[c].type;
          var fieldIsArray = formattedResult.fields[c].is_array;
          if (fieldIsArray) {
            if (data.rows[r].cols[c].is_null) {
              row[fieldName] = &quot;NULL&quot;;
              continue;
            }
            row[fieldName] = [];
            var arrayNumElems = data.rows[r].cols[c].val.arr_val.length;
            for (var e = 0; e &lt; arrayNumElems; e++) {
              var elemDatum = data.rows[r].cols[c].val.arr_val[e];
              if (elemDatum.is_null) {
                row[fieldName].push(&quot;NULL&quot;);
                continue;
              }
              switch(fieldType) {
                case &quot;BOOL&quot;:
                  row[fieldName].push(elemDatum.val.int_val ? true : false);
                  break;
                case &quot;SMALLINT&quot;:
                case &quot;INT&quot;:
                case &quot;BIGINT&quot;:
                  row[fieldName].push(elemDatum.val.int_val);
                  break;
                case &quot;FLOAT&quot;:
                case &quot;DOUBLE&quot;:
                case &quot;DECIMAL&quot;:
                  row[fieldName].push(elemDatum.val.real_val);
                  break;
                case &quot;STR&quot;:
                  row[fieldName].push(elemDatum.val.str_val);
                  break;
                case &quot;TIME&quot;:
                case &quot;TIMESTAMP&quot;:
                case &quot;DATE&quot;:
                  row[fieldName].push(elemDatum.val.int_val * 1000);
                  break;
              }
            }
          }
          else {
            var scalarDatum = data.rows[r].cols[c];
            if (scalarDatum.is_null) {
              row[fieldName] = &quot;NULL&quot;;
              continue;
            }
            switch (fieldType) {
              case &quot;BOOL&quot;:
                row[fieldName] = scalarDatum.val.int_val ? true : false;
                break;
              case &quot;SMALLINT&quot;:
              case &quot;INT&quot;:
              case &quot;BIGINT&quot;:
                row[fieldName] = scalarDatum.val.int_val;
                break;
              case &quot;FLOAT&quot;:
              case &quot;DOUBLE&quot;:
              case &quot;DECIMAL&quot;:
                row[fieldName] = scalarDatum.val.real_val;
                break;
              case &quot;STR&quot;:
                row[fieldName] = scalarDatum.val.str_val;
                break;
              case &quot;TIME&quot;:
              case &quot;TIMESTAMP&quot;:
              case &quot;DATE&quot;:
                row[fieldName] = new Date(scalarDatum.val.int_val * 1000);
                break;
            }
          }
        }
        formattedResult.results.push(row);
      }
      return formattedResult;
    }

    function processResults(isImage, eliminateNullRows, query, callbacks, result) {
      if (_logging &amp;&amp; result.execution_time_ms)
        console.log(query + &quot;: &quot; + result.execution_time_ms + &quot; ms&quot;);
      var hasCallback = typeof callbacks !== &apos;undefined&apos;;
      if (isImage) {
        if (hasCallback) {
          callbacks.pop()(result,callbacks);
        }
        else {
          return result;
        }
      }
      else {
        result = result.row_set;
        var formattedResult = null;
        if (result.is_columnar) {
          formattedResult = processColumnarResults(result,eliminateNullRows);
        }
        else {
          formattedResult = processRowResults(result,eliminateNullRows);
        }
        if (hasCallback) {
          callbacks.pop()(formattedResult.results,callbacks);
        }
        else {
          return formattedResult.results;
        }
      }
    }

    function getDatabases () {
      testConnection();
      var databases = null;
      try {
        databases = client.get_databases();
      }
      catch (err) {
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          databases = client.get_databases();
        }
      }
      var dbNames = [];
      $(databases).each(function(){dbNames.push(this.db_name)});
      return dbNames;
    }

    function getTables() {
      testConnection();
      var tabs = null;
      try {
        tabs = client.get_tables(sessionId);
      }
      catch (err) {
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          tabs = client.get_tables(sessionId);
        }
      }

      var numTables = tabs.length;
      var tableInfo = [];
      for (var t = 0; t &lt; numTables; t++) {
        tableInfo.push({&quot;name&quot;: tabs[t], &quot;label&quot;: &quot;obs&quot;});
      }
      return tableInfo;
    }

    function invertDatumTypes() {
      for (var key in TDatumType) {
        datumEnum[TDatumType[key]] = key;
      }
    }

    function getFields(tableName) {
      testConnection();
      var fields = client.get_table_descriptor(sessionId,tableName);
      var fieldsArray = [];
      // silly to change this from map to array
      // - then later it turns back to map
      for (var key in fields) {
        fieldsArray.push({&quot;name&quot;: key, &quot;type&quot;: datumEnum[fields[key].col_type.type], &quot;is_array&quot;:fields[key].col_type.is_array, &quot;is_dict&quot;: fields[key].col_type.encoding == TEncodingType[&quot;DICT&quot;]});
      }
      return fieldsArray;
    }

    function createTable(tableName, rowDesc, callback) {
      try {
        result = client.send_create_table(sessionId, tableName, rowDesc, callback);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.send_create_table(sessionId, tableName, rowDesc, callback);
        }
      }
      return result;
    }

    function importTable(tableName, fileName, copyParams, callback) {
      copyParams.delimiter = copyParams.delimiter || &quot;&quot;;
      try {
        result = client.send_import_table(sessionId, tableName, fileName, copyParams, callback);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          result = client.send_import_table(sessionId, tableName, fileName, copyParams, callback);
        }
      }
      return result;
    }

    function importTableStatus(importId, callback) {
      testConnection();
      callback = callback || null;
      var import_status = null;
      try {
        import_status = client.import_table_status(sessionId, importId, callback);
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          import_status = client.import_table_status(sessionId, importId, callback);
        }
      }
      return import_status;
    }

    function getRowsForPixels(pixels, table_name, col_names, callbacks) {
      var widget_id = 1;  // INT
      var column_format = true; //BOOL
      callbacks = callbacks || null;
      var curNonce = (nonce++).toString();
      try {
        if (!callbacks) 
            return processPixelResults(undefined, client.get_rows_for_pixels(sessionId, widget_id, pixels, table_name, col_names, column_format, curNonce)) ;
        client.get_rows_for_pixels(sessionId, widget_id, pixels, table_name, col_names, column_format, curNonce, processPixelResults.bind(this, callbacks));
      }
      catch(err) {
        console.log(err);
        if (err.name == &quot;ThriftException&quot;) {
          connect();
          if (!callbacks) 
            return processPixelResults(undefined, client.get_rows_for_pixels(sessionId, widget_id, pixels, table_name, col_names, column_format, curNonce)) ;
          client.get_rows_for_pixels(sessionId, widget_id, pixels, table_name, col_names, column_format, curNonce, processPixelResults.bind(this, callbacks));
        }
      }
      return curNonce;
    }

    function processPixelResults(callbacks, results) {
      var results = results.pixel_rows;
      var numPixels = results.length;
      var resultsMap = {};
      for (var p = 0; p &lt; numPixels; p++) {
        results[p].row_set = processResults(false, false, &quot;pixel request&quot;, undefined, results[p]);
      }
      if (!callbacks) 
        return results;
      callbacks.pop()(results,callbacks);
    }



    invertDatumTypes();
    return mapdcon;
  }

})(typeof exports !== &apos;undefined&apos; &amp;&amp; exports || this);
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
